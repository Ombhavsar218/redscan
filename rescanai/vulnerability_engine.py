"""
RedScan AI - Advanced Vulnerability Detection Engine
Comprehensive vulnerability detection including:
- SQL Injection testing
- XSS (Cross-Site Scripting) detection
- Security headers analysis
- Open ports vulnerability assessment
- OWASP Top 10 coverage
"""

import requests
import socket
import re
import time
import json
import urllib.parse
from typing import List, Dict, Tuple, Optional
from concurrent.futures import ThreadPoolExecutor, as_completed
import ssl
import subprocess
import base64
from bs4 import BeautifulSoup
import hashlib

class AdvancedVulnerabilityEngine:
    """
    Advanced vulnerability detection engine with comprehensive testing capabilities
    Features 1% increment progress tracking for detailed scanning
    """
    
    def __init__(self, target: str, progress_callback=None):
        self.target = target
        self.progress_callback = progress_callback
        self.current_progress = 0
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'RedScan-AI-Security-Scanner/1.0'
        })
        
        self.results = {
            'target': target,
            'scan_type': 'Advanced Vulnerability Detection',
            'timestamp': time.strftime('%Y-%m-%d %H:%M:%S'),
            'sql_injection': [],
            'xss_vulnerabilities': [],
            'security_headers': {},
            'open_ports': [],
            'owasp_top10': [],
            'ssl_vulnerabilities': [],
            'authentication_issues': [],
            'session_management': [],
            'input_validation': [],
            'recommendations': []
        }
    
    def update_progress(self, increment=1, status="Scanning..."):
        """Update progress by 1% increments"""
        self.current_progress += increment
        if self.current_progress > 100:
            self.current_progress = 100
        if self.progress_callback:
            self.progress_callback(self.current_progress, status)
        time.sleep(0.05)
    
    def run_comprehensive_vulnerability_scan(self):
        """Run comprehensive vulnerability detection with 1% increments"""
        self.update_progress(0, "Starting advanced vulnerability detection...")
        
        # Phase 1: Port Scanning and Service Detection (1-15%)
        self.update_progress(1, "Initializing port scanner...")
        self.scan_open_ports()
        
        # Phase 2: Security Headers Analysis (16-25%)
        self.update_progress(1, "Analyzing security headers...")
        self.analyze_security_headers()
        
        # Phase 3: SSL/TLS Vulnerability Testing (26-35%)
        self.update_progress(1, "Testing SSL/TLS configuration...")
        self.test_ssl_vulnerabilities()
        
        # Phase 4: SQL Injection Testing (36-55%)
        self.update_progress(1, "Starting SQL injection tests...")
        self.test_sql_injection()
        
        # Phase 5: XSS Vulnerability Testing (56-70%)
        self.update_progress(1, "Testing for XSS vulnerabilities...")
        self.test_xss_vulnerabilities()
        
        # Phase 6: Authentication and Session Testing (71-80%)
        self.update_progress(1, "Testing authentication mechanisms...")
        self.test_authentication_issues()
        
        # Phase 7: Input Validation Testing (81-90%)
        self.update_progress(1, "Testing input validation...")
        self.test_input_validation()
        
        # Phase 8: OWASP Top 10 Assessment (91-95%)
        self.update_progress(1, "Assessing OWASP Top 10 vulnerabilities...")
        self.assess_owasp_top10()
        
        # Phase 9: Generate Recommendations (96-100%)
        self.update_progress(1, "Generating security recommendations...")
        self.generate_vulnerability_recommendations()
        
        self.update_progress(4, "Advanced vulnerability scan completed!")
        return self.results
    
    def scan_open_ports(self):
        """Comprehensive port scanning with vulnerability assessment"""
        self.update_progress(1, "Scanning common ports...")
        
        # Common ports with known vulnerabilities
        vulnerable_ports = {
            21: {'service': 'FTP', 'vulns': ['Anonymous access', 'Weak encryption']},
            22: {'service': 'SSH', 'vulns': ['Weak algorithms', 'Brute force']},
            23: {'service': 'Telnet', 'vulns': ['Unencrypted communication']},
            25: {'service': 'SMTP', 'vulns': ['Open relay', 'No encryption']},
            53: {'service': 'DNS', 'vulns': ['Zone transfer', 'Cache poisoning']},
            80: {'service': 'HTTP', 'vulns': ['No HTTPS', 'Web vulnerabilities']},
            110: {'service': 'POP3', 'vulns': ['Unencrypted authentication']},
            135: {'service': 'RPC', 'vulns': ['Remote code execution']},
            139: {'service': 'NetBIOS', 'vulns': ['Information disclosure']},
            143: {'service': 'IMAP', 'vulns': ['Unencrypted authentication']},
            443: {'service': 'HTTPS', 'vulns': ['SSL/TLS issues', 'Certificate problems']},
            445: {'service': 'SMB', 'vulns': ['EternalBlue', 'Null sessions']},
            993: {'service': 'IMAPS', 'vulns': ['SSL/TLS configuration']},
            995: {'service': 'POP3S', 'vulns': ['SSL/TLS configuration']},
            1433: {'service': 'MSSQL', 'vulns': ['SQL injection', 'Weak authentication']},
            1521: {'service': 'Oracle', 'vulns': ['Default credentials', 'SQL injection']},
            3306: {'service': 'MySQL', 'vulns': ['SQL injection', 'Weak authentication']},
            3389: {'service': 'RDP', 'vulns': ['BlueKeep', 'Brute force']},
            5432: {'service': 'PostgreSQL', 'vulns': ['SQL injection', 'Privilege escalation']},
            5900: {'service': 'VNC', 'vulns': ['Weak authentication', 'No encryption']},
            6379: {'service': 'Redis', 'vulns': ['No authentication', 'Code execution']},
            8080: {'service': 'HTTP-Alt', 'vulns': ['Web vulnerabilities', 'Admin interfaces']},
            27017: {'service': 'MongoDB', 'vulns': ['No authentication', 'Injection attacks']}
        }
        
        open_ports = []
        for port, info in vulnerable_ports.items():
            self.update_progress(1, f"Testing port {port} ({info['service']})...")
            
            if self.check_port(port):
                port_info = {
                    'port': port,
                    'service': info['service'],
                    'status': 'open',
                    'vulnerabilities': info['vulns'],
                    'risk_level': self.assess_port_risk(port, info['service'])
                }
                open_ports.append(port_info)
                
                # Test specific vulnerabilities for this port
                self.test_port_specific_vulnerabilities(port, info)
        
        self.results['open_ports'] = open_ports
    
    def check_port(self, port, timeout=2):
        """Check if a port is open"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(timeout)
            result = sock.connect_ex((self.target, port))
            sock.close()
            return result == 0
        except:
            return False
    
    def assess_port_risk(self, port, service):
        """Assess risk level for open ports"""
        critical_ports = [445, 3389, 1433, 3306, 5432, 6379, 27017]
        high_risk_ports = [21, 23, 135, 139, 5900]
        medium_risk_ports = [22, 25, 53, 110, 143]
        
        if port in critical_ports:
            return 'Critical'
        elif port in high_risk_ports:
            return 'High'
        elif port in medium_risk_ports:
            return 'Medium'
        else:
            return 'Low'
    
    def test_port_specific_vulnerabilities(self, port, info):
        """Test specific vulnerabilities for each port"""
        if port == 21:  # FTP
            self.test_ftp_vulnerabilities()
        elif port == 22:  # SSH
            self.test_ssh_vulnerabilities()
        elif port == 445:  # SMB
            self.test_smb_vulnerabilities()
        elif port in [3306, 1433, 5432]:  # Databases
            self.test_database_vulnerabilities(port)
    
    def analyze_security_headers(self):
        """Comprehensive security headers analysis"""
        self.update_progress(1, "Testing HTTP security headers...")
        
        security_headers = {
            'Strict-Transport-Security': {
                'description': 'Enforces HTTPS connections',
                'risk': 'Medium',
                'recommendation': 'Add HSTS header with max-age directive'
            },
            'Content-Security-Policy': {
                'description': 'Prevents XSS and injection attacks',
                'risk': 'High',
                'recommendation': 'Implement comprehensive CSP policy'
            },
            'X-Frame-Options': {
                'description': 'Prevents clickjacking attacks',
                'risk': 'Medium',
                'recommendation': 'Set to DENY or SAMEORIGIN'
            },
            'X-Content-Type-Options': {
                'description': 'Prevents MIME type sniffing',
                'risk': 'Medium',
                'recommendation': 'Set to nosniff'
            },
            'X-XSS-Protection': {
                'description': 'Enables XSS filtering',
                'risk': 'Medium',
                'recommendation': 'Set to 1; mode=block'
            },
            'Referrer-Policy': {
                'description': 'Controls referrer information',
                'risk': 'Low',
                'recommendation': 'Set appropriate referrer policy'
            },
            'Permissions-Policy': {
                'description': 'Controls browser features',
                'risk': 'Low',
                'recommendation': 'Restrict unnecessary permissions'
            }
        }
        
        try:
            # Test HTTP
            self.update_progress(1, "Testing HTTP headers...")
            http_response = requests.get(f'http://{self.target}', timeout=5)
            self.analyze_response_headers(http_response, security_headers, 'HTTP')
            
            # Test HTTPS if available
            self.update_progress(1, "Testing HTTPS headers...")
            try:
                https_response = requests.get(f'https://{self.target}', timeout=5, verify=False)
                self.analyze_response_headers(https_response, security_headers, 'HTTPS')
            except:
                pass
                
        except Exception as e:
            self.update_progress(2, f"Error analyzing headers: {str(e)}")
    
    def analyze_response_headers(self, response, security_headers, protocol):
        """Analyze response headers for security issues"""
        headers_analysis = {}
        
        for header, info in security_headers.items():
            if header in response.headers:
                headers_analysis[header] = {
                    'present': True,
                    'value': response.headers[header],
                    'status': 'Configured'
                }
            else:
                headers_analysis[header] = {
                    'present': False,
                    'value': None,
                    'status': 'Missing',
                    'risk': info['risk'],
                    'recommendation': info['recommendation']
                }
        
        # Check for information disclosure headers
        disclosure_headers = ['Server', 'X-Powered-By', 'X-AspNet-Version']
        for header in disclosure_headers:
            if header in response.headers:
                headers_analysis[f'{header}_disclosure'] = {
                    'present': True,
                    'value': response.headers[header],
                    'status': 'Information Disclosure',
                    'risk': 'Low',
                    'recommendation': f'Remove or obfuscate {header} header'
                }
        
        self.results['security_headers'][protocol] = headers_analysis
    
    def test_ssl_vulnerabilities(self):
        """Test SSL/TLS vulnerabilities"""
        self.update_progress(1, "Testing SSL/TLS configuration...")
        
        ssl_tests = [
            'SSLv2 support',
            'SSLv3 support', 
            'Weak cipher suites',
            'Certificate validation',
            'BEAST vulnerability',
            'POODLE vulnerability',
            'Heartbleed vulnerability'
        ]
        
        ssl_vulnerabilities = []
        
        for test in ssl_tests:
            self.update_progress(1, f"Testing {test}...")
            
            if test == 'Certificate validation':
                cert_issues = self.test_certificate_validation()
                if cert_issues:
                    ssl_vulnerabilities.extend(cert_issues)
            
            elif test == 'Weak cipher suites':
                weak_ciphers = self.test_weak_ciphers()
                if weak_ciphers:
                    ssl_vulnerabilities.extend(weak_ciphers)
        
        self.results['ssl_vulnerabilities'] = ssl_vulnerabilities
    
    def test_certificate_validation(self):
        """Test SSL certificate validation"""
        issues = []
        try:
            # Test certificate validity
            context = ssl.create_default_context()
            with socket.create_connection((self.target, 443), timeout=5) as sock:
                with context.wrap_socket(sock, server_hostname=self.target) as ssock:
                    cert = ssock.getpeercert()
                    
                    # Check certificate expiration
                    import datetime
                    not_after = datetime.datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                    days_until_expiry = (not_after - datetime.datetime.now()).days
                    
                    if days_until_expiry < 30:
                        issues.append({
                            'type': 'Certificate Expiring Soon',
                            'severity': 'Medium',
                            'description': f'Certificate expires in {days_until_expiry} days'
                        })
                    
                    # Check for self-signed certificate
                    if cert.get('issuer') == cert.get('subject'):
                        issues.append({
                            'type': 'Self-Signed Certificate',
                            'severity': 'Medium',
                            'description': 'Certificate is self-signed'
                        })
        
        except ssl.SSLError as e:
            issues.append({
                'type': 'SSL Configuration Error',
                'severity': 'High',
                'description': f'SSL error: {str(e)}'
            })
        except:
            pass
        
        return issues
    
    def test_weak_ciphers(self):
        """Test for weak cipher suites"""
        weak_ciphers = []
        
        # This is a simplified test - in practice, you'd use tools like SSLyze
        try:
            context = ssl.create_default_context()
            context.set_ciphers('ALL:@SECLEVEL=0')  # Allow weak ciphers for testing
            
            with socket.create_connection((self.target, 443), timeout=5) as sock:
                with context.wrap_socket(sock, server_hostname=self.target) as ssock:
                    cipher = ssock.cipher()
                    if cipher:
                        cipher_name = cipher[0]
                        # Check for known weak ciphers
                        weak_patterns = ['RC4', 'DES', 'MD5', 'NULL', 'EXPORT']
                        if any(pattern in cipher_name for pattern in weak_patterns):
                            weak_ciphers.append({
                                'type': 'Weak Cipher Suite',
                                'severity': 'High',
                                'description': f'Weak cipher detected: {cipher_name}'
                            })
        except:
            pass
        
        return weak_ciphers
    
    def test_sql_injection(self):
        """Comprehensive SQL injection testing"""
        self.update_progress(1, "Discovering web forms and parameters...")
        
        # SQL injection payloads
        sql_payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' /*",
            "'; DROP TABLE users; --",
            "' UNION SELECT NULL, NULL, NULL --",
            "' AND 1=1 --",
            "' AND 1=2 --",
            "admin'--",
            "admin' #",
            "admin'/*",
            "' OR 1=1#",
            "' OR 1=1--",
            "' OR 1=1/*",
            "') OR '1'='1--",
            "') OR ('1'='1--"
        ]
        
        # Error-based detection patterns
        error_patterns = [
            r"SQL syntax.*MySQL",
            r"Warning.*mysql_.*",
            r"valid MySQL result",
            r"MySqlClient\.",
            r"PostgreSQL.*ERROR",
            r"Warning.*\Wpg_.*",
            r"valid PostgreSQL result",
            r"Npgsql\.",
            r"Driver.* SQL[\-\_\ ]*Server",
            r"OLE DB.* SQL Server",
            r"(\W|\A)SQL Server.*Driver",
            r"Warning.*mssql_.*",
            r"(\W|\A)SQL Server.*[0-9a-fA-F]{8}",
            r"Exception.*\WSystem\.Data\.SqlClient\.",
            r"Exception.*\WRoadhouse\.Cms\.",
            r"Microsoft Access Driver",
            r"JET Database Engine",
            r"Access Database Engine",
            r"ODBC Microsoft Access",
            r"Syntax error.*query expression"
        ]
        
        sql_vulnerabilities = []
        
        # Test common web paths
        test_paths = [
            '/',
            '/login',
            '/admin',
            '/search',
            '/user',
            '/product',
            '/api/users',
            '/api/login'
        ]
        
        for path in test_paths:
            self.update_progress(1, f"Testing SQL injection on {path}...")
            
            try:
                # Test GET parameters
                for payload in sql_payloads[:5]:  # Limit payloads for speed
                    test_url = f"http://{self.target}{path}?id={urllib.parse.quote(payload)}"
                    
                    try:
                        response = self.session.get(test_url, timeout=5)
                        
                        # Check for SQL error patterns
                        for pattern in error_patterns:
                            if re.search(pattern, response.text, re.IGNORECASE):
                                sql_vulnerabilities.append({
                                    'type': 'SQL Injection (Error-based)',
                                    'severity': 'Critical',
                                    'url': test_url,
                                    'parameter': 'id',
                                    'payload': payload,
                                    'evidence': pattern,
                                    'description': f'SQL injection vulnerability detected in {path}'
                                })
                                break
                    except:
                        continue
                
                # Test POST parameters (if forms are found)
                self.test_post_sql_injection(path, sql_payloads[:3], error_patterns)
                
            except Exception as e:
                continue
        
        self.results['sql_injection'] = sql_vulnerabilities
    
    def test_post_sql_injection(self, path, payloads, error_patterns):
        """Test POST-based SQL injection"""
        try:
            # Get the page to find forms
            response = self.session.get(f"http://{self.target}{path}", timeout=5)
            soup = BeautifulSoup(response.text, 'html.parser')
            
            forms = soup.find_all('form')
            for form in forms:
                action = form.get('action', path)
                method = form.get('method', 'GET').upper()
                
                if method == 'POST':
                    # Extract form fields
                    inputs = form.find_all(['input', 'textarea', 'select'])
                    form_data = {}
                    
                    for input_field in inputs:
                        name = input_field.get('name')
                        if name and input_field.get('type') != 'submit':
                            form_data[name] = 'test'
                    
                    # Test each field with SQL payloads
                    for field_name in form_data.keys():
                        for payload in payloads:
                            test_data = form_data.copy()
                            test_data[field_name] = payload
                            
                            try:
                                post_response = self.session.post(
                                    f"http://{self.target}{action}",
                                    data=test_data,
                                    timeout=5
                                )
                                
                                # Check for SQL errors
                                for pattern in error_patterns:
                                    if re.search(pattern, post_response.text, re.IGNORECASE):
                                        self.results['sql_injection'].append({
                                            'type': 'SQL Injection (POST)',
                                            'severity': 'Critical',
                                            'url': f"http://{self.target}{action}",
                                            'parameter': field_name,
                                            'payload': payload,
                                            'evidence': pattern,
                                            'description': f'POST SQL injection in form field {field_name}'
                                        })
                                        break
                            except:
                                continue
        except:
            pass
    
    def test_xss_vulnerabilities(self):
        """Comprehensive XSS vulnerability testing"""
        self.update_progress(1, "Testing for XSS vulnerabilities...")
        
        # XSS payloads
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "javascript:alert('XSS')",
            "<iframe src=javascript:alert('XSS')>",
            "<body onload=alert('XSS')>",
            "<input onfocus=alert('XSS') autofocus>",
            "<select onfocus=alert('XSS') autofocus>",
            "<textarea onfocus=alert('XSS') autofocus>",
            "<keygen onfocus=alert('XSS') autofocus>",
            "<video><source onerror=alert('XSS')>",
            "<audio src=x onerror=alert('XSS')>",
            "<details open ontoggle=alert('XSS')>",
            "'-alert('XSS')-'",
            "\";alert('XSS');//"
        ]
        
        xss_vulnerabilities = []
        
        # Test common parameters
        test_params = ['q', 'search', 'query', 'name', 'message', 'comment', 'text', 'input']
        test_paths = ['/', '/search', '/contact', '/comment', '/feedback']
        
        for path in test_paths:
            self.update_progress(1, f"Testing XSS on {path}...")
            
            for param in test_params:
                for payload in xss_payloads[:5]:  # Limit for speed
                    try:
                        # Test reflected XSS
                        test_url = f"http://{self.target}{path}?{param}={urllib.parse.quote(payload)}"
                        response = self.session.get(test_url, timeout=5)
                        
                        # Check if payload is reflected in response
                        if payload in response.text or payload.replace("'", "&#x27;") in response.text:
                            # Additional checks to confirm XSS
                            if self.confirm_xss_vulnerability(response.text, payload):
                                xss_vulnerabilities.append({
                                    'type': 'Reflected XSS',
                                    'severity': 'High',
                                    'url': test_url,
                                    'parameter': param,
                                    'payload': payload,
                                    'description': f'Reflected XSS vulnerability in {param} parameter'
                                })
                    except:
                        continue
        
        # Test stored XSS (simplified)
        self.test_stored_xss(xss_payloads[:3])
        
        self.results['xss_vulnerabilities'] = xss_vulnerabilities
    
    def confirm_xss_vulnerability(self, response_text, payload):
        """Confirm XSS vulnerability with additional checks"""
        # Check if payload is in a dangerous context
        dangerous_contexts = [
            r'<script[^>]*>' + re.escape(payload),
            r'<[^>]+on\w+=["\']?' + re.escape(payload),
            r'href=["\']?' + re.escape(payload),
            r'src=["\']?' + re.escape(payload)
        ]
        
        for context in dangerous_contexts:
            if re.search(context, response_text, re.IGNORECASE):
                return True
        
        # Check if script tags are not filtered
        if '<script>' in payload and '<script>' in response_text:
            return True
        
        return False
    
    def test_stored_xss(self, payloads):
        """Test for stored XSS vulnerabilities"""
        self.update_progress(1, "Testing stored XSS...")
        
        # Look for forms that might store data
        try:
            response = self.session.get(f"http://{self.target}", timeout=5)
            soup = BeautifulSoup(response.text, 'html.parser')
            
            forms = soup.find_all('form')
            for form in forms:
                action = form.get('action', '/')
                method = form.get('method', 'GET').upper()
                
                # Look for comment/message forms
                if any(keyword in str(form).lower() for keyword in ['comment', 'message', 'feedback', 'review']):
                    if method == 'POST':
                        inputs = form.find_all(['input', 'textarea'])
                        for input_field in inputs:
                            name = input_field.get('name')
                            if name and input_field.get('type') not in ['submit', 'hidden']:
                                # Test with XSS payload
                                for payload in payloads:
                                    self.test_stored_xss_field(action, name, payload)
        except:
            pass
    
    def test_stored_xss_field(self, action, field_name, payload):
        """Test individual field for stored XSS"""
        try:
            # Submit payload
            data = {field_name: payload}
            self.session.post(f"http://{self.target}{action}", data=data, timeout=5)
            
            # Check if payload is stored by visiting the page again
            response = self.session.get(f"http://{self.target}{action}", timeout=5)
            
            if payload in response.text:
                self.results['xss_vulnerabilities'].append({
                    'type': 'Stored XSS',
                    'severity': 'Critical',
                    'url': f"http://{self.target}{action}",
                    'parameter': field_name,
                    'payload': payload,
                    'description': f'Stored XSS vulnerability in {field_name} field'
                })
        except:
            pass
    
    def test_authentication_issues(self):
        """Test authentication and session management issues"""
        self.update_progress(1, "Testing authentication mechanisms...")
        
        auth_issues = []
        
        # Test for default credentials
        self.update_progress(1, "Testing default credentials...")
        default_creds = [
            ('admin', 'admin'),
            ('admin', 'password'),
            ('admin', '123456'),
            ('root', 'root'),
            ('user', 'user'),
            ('test', 'test'),
            ('guest', 'guest')
        ]
        
        login_paths = ['/login', '/admin', '/signin', '/auth']
        
        for path in login_paths:
            for username, password in default_creds:
                if self.test_login_credentials(path, username, password):
                    auth_issues.append({
                        'type': 'Default Credentials',
                        'severity': 'Critical',
                        'url': f"http://{self.target}{path}",
                        'credentials': f"{username}:{password}",
                        'description': f'Default credentials accepted: {username}/{password}'
                    })
        
        # Test session management
        self.update_progress(1, "Testing session management...")
        session_issues = self.test_session_management()
        auth_issues.extend(session_issues)
        
        # Test password policies
        self.update_progress(1, "Testing password policies...")
        password_issues = self.test_password_policies()
        auth_issues.extend(password_issues)
        
        self.results['authentication_issues'] = auth_issues
    
    def test_login_credentials(self, path, username, password):
        """Test login with specific credentials"""
        try:
            # Get login page
            response = self.session.get(f"http://{self.target}{path}", timeout=5)
            soup = BeautifulSoup(response.text, 'html.parser')
            
            # Find login form
            form = soup.find('form')
            if form:
                action = form.get('action', path)
                
                # Find username and password fields
                username_field = form.find('input', {'type': ['text', 'email']}) or form.find('input', {'name': re.compile(r'user|login|email', re.I)})
                password_field = form.find('input', {'type': 'password'}) or form.find('input', {'name': re.compile(r'pass|pwd', re.I)})
                
                if username_field and password_field:
                    data = {
                        username_field.get('name'): username,
                        password_field.get('name'): password
                    }
                    
                    # Submit login
                    login_response = self.session.post(f"http://{self.target}{action}", data=data, timeout=5)
                    
                    # Check for successful login indicators
                    success_indicators = ['dashboard', 'welcome', 'logout', 'profile', 'admin panel']
                    failure_indicators = ['invalid', 'incorrect', 'failed', 'error', 'denied']
                    
                    response_text = login_response.text.lower()
                    
                    # Check if login was successful
                    if any(indicator in response_text for indicator in success_indicators):
                        if not any(indicator in response_text for indicator in failure_indicators):
                            return True
        except:
            pass
        
        return False
    
    def test_session_management(self):
        """Test session management vulnerabilities"""
        session_issues = []
        
        try:
            # Test session fixation
            response = self.session.get(f"http://{self.target}", timeout=5)
            
            # Check for secure session cookies
            for cookie in self.session.cookies:
                if not cookie.secure and 'https' in self.target:
                    session_issues.append({
                        'type': 'Insecure Session Cookie',
                        'severity': 'Medium',
                        'description': f'Session cookie {cookie.name} not marked as secure'
                    })
                
                if not cookie.has_nonstandard_attr('HttpOnly'):
                    session_issues.append({
                        'type': 'Session Cookie Missing HttpOnly',
                        'severity': 'Medium',
                        'description': f'Session cookie {cookie.name} missing HttpOnly flag'
                    })
        except:
            pass
        
        return session_issues
    
    def test_password_policies(self):
        """Test password policy enforcement"""
        password_issues = []
        
        # Test weak password acceptance
        weak_passwords = ['123456', 'password', 'admin', 'test', '12345']
        
        # This would require finding registration forms
        # Simplified implementation
        try:
            response = self.session.get(f"http://{self.target}/register", timeout=5)
            if response.status_code == 200:
                # If registration page exists, it might have weak password policies
                if 'password' in response.text.lower():
                    password_issues.append({
                        'type': 'Password Policy Unknown',
                        'severity': 'Low',
                        'description': 'Registration form found - password policy should be verified manually'
                    })
        except:
            pass
        
        return password_issues
    
    def test_input_validation(self):
        """Test input validation vulnerabilities"""
        self.update_progress(1, "Testing input validation...")
        
        validation_issues = []
        
        # Test file upload vulnerabilities
        self.update_progress(1, "Testing file upload security...")
        upload_issues = self.test_file_upload_vulnerabilities()
        validation_issues.extend(upload_issues)
        
        # Test command injection
        self.update_progress(1, "Testing command injection...")
        command_issues = self.test_command_injection()
        validation_issues.extend(command_issues)
        
        # Test path traversal
        self.update_progress(1, "Testing path traversal...")
        path_issues = self.test_path_traversal()
        validation_issues.extend(path_issues)
        
        self.results['input_validation'] = validation_issues
    
    def test_file_upload_vulnerabilities(self):
        """Test file upload security"""
        upload_issues = []
        
        try:
            # Look for file upload forms
            response = self.session.get(f"http://{self.target}", timeout=5)
            soup = BeautifulSoup(response.text, 'html.parser')
            
            file_inputs = soup.find_all('input', {'type': 'file'})
            
            for file_input in file_inputs:
                form = file_input.find_parent('form')
                if form:
                    upload_issues.append({
                        'type': 'File Upload Found',
                        'severity': 'Medium',
                        'description': 'File upload functionality detected - manual testing recommended'
                    })
        except:
            pass
        
        return upload_issues
    
    def test_command_injection(self):
        """Test command injection vulnerabilities"""
        command_issues = []
        
        # Command injection payloads
        cmd_payloads = [
            '; ls',
            '| whoami',
            '& dir',
            '`id`',
            '$(whoami)',
            '; cat /etc/passwd',
            '| type C:\\Windows\\System32\\drivers\\etc\\hosts'
        ]
        
        test_params = ['cmd', 'command', 'exec', 'system', 'ping', 'host']
        
        for param in test_params:
            for payload in cmd_payloads[:3]:  # Limit for speed
                try:
                    test_url = f"http://{self.target}/?{param}={urllib.parse.quote(payload)}"
                    response = self.session.get(test_url, timeout=5)
                    
                    # Look for command execution indicators
                    if any(indicator in response.text.lower() for indicator in ['root:', 'administrator', 'uid=', 'gid=']):
                        command_issues.append({
                            'type': 'Command Injection',
                            'severity': 'Critical',
                            'url': test_url,
                            'parameter': param,
                            'payload': payload,
                            'description': f'Command injection vulnerability in {param} parameter'
                        })
                except:
                    continue
        
        return command_issues
    
    def test_path_traversal(self):
        """Test path traversal vulnerabilities"""
        path_issues = []
        
        # Path traversal payloads
        traversal_payloads = [
            '../../../etc/passwd',
            '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
            '....//....//....//etc/passwd',
            '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
            '..%252f..%252f..%252fetc%252fpasswd'
        ]
        
        test_params = ['file', 'path', 'page', 'include', 'doc', 'document']
        
        for param in test_params:
            for payload in traversal_payloads[:3]:  # Limit for speed
                try:
                    test_url = f"http://{self.target}/?{param}={urllib.parse.quote(payload)}"
                    response = self.session.get(test_url, timeout=5)
                    
                    # Look for file content indicators
                    if any(indicator in response.text.lower() for indicator in ['root:', '[boot loader]', 'localhost']):
                        path_issues.append({
                            'type': 'Path Traversal',
                            'severity': 'High',
                            'url': test_url,
                            'parameter': param,
                            'payload': payload,
                            'description': f'Path traversal vulnerability in {param} parameter'
                        })
                except:
                    continue
        
        return path_issues
    
    def assess_owasp_top10(self):
        """Assess OWASP Top 10 vulnerabilities"""
        self.update_progress(1, "Assessing OWASP Top 10...")
        
        owasp_assessment = []
        
        # A01:2021 – Broken Access Control
        if self.results['authentication_issues']:
            owasp_assessment.append({
                'category': 'A01:2021 - Broken Access Control',
                'status': 'Vulnerable',
                'severity': 'High',
                'findings': len(self.results['authentication_issues'])
            })
        
        # A02:2021 – Cryptographic Failures
        if self.results['ssl_vulnerabilities']:
            owasp_assessment.append({
                'category': 'A02:2021 - Cryptographic Failures',
                'status': 'Vulnerable',
                'severity': 'High',
                'findings': len(self.results['ssl_vulnerabilities'])
            })
        
        # A03:2021 – Injection
        injection_count = len(self.results['sql_injection']) + len([v for v in self.results['input_validation'] if 'injection' in v['type'].lower()])
        if injection_count > 0:
            owasp_assessment.append({
                'category': 'A03:2021 - Injection',
                'status': 'Vulnerable',
                'severity': 'Critical',
                'findings': injection_count
            })
        
        # A04:2021 – Insecure Design (requires manual assessment)
        owasp_assessment.append({
            'category': 'A04:2021 - Insecure Design',
            'status': 'Manual Review Required',
            'severity': 'Medium',
            'findings': 0
        })
        
        # A05:2021 – Security Misconfiguration
        misconfig_count = len([h for headers in self.results['security_headers'].values() for h in headers.values() if not h.get('present', True)])
        if misconfig_count > 0:
            owasp_assessment.append({
                'category': 'A05:2021 - Security Misconfiguration',
                'status': 'Vulnerable',
                'severity': 'Medium',
                'findings': misconfig_count
            })
        
        # A06:2021 – Vulnerable and Outdated Components (requires version detection)
        owasp_assessment.append({
            'category': 'A06:2021 - Vulnerable and Outdated Components',
            'status': 'Manual Review Required',
            'severity': 'Medium',
            'findings': 0
        })
        
        # A07:2021 – Identification and Authentication Failures
        if self.results['authentication_issues']:
            owasp_assessment.append({
                'category': 'A07:2021 - Identification and Authentication Failures',
                'status': 'Vulnerable',
                'severity': 'High',
                'findings': len(self.results['authentication_issues'])
            })
        
        # A08:2021 – Software and Data Integrity Failures
        owasp_assessment.append({
            'category': 'A08:2021 - Software and Data Integrity Failures',
            'status': 'Manual Review Required',
            'severity': 'Medium',
            'findings': 0
        })
        
        # A09:2021 – Security Logging and Monitoring Failures
        owasp_assessment.append({
            'category': 'A09:2021 - Security Logging and Monitoring Failures',
            'status': 'Manual Review Required',
            'severity': 'Low',
            'findings': 0
        })
        
        # A10:2021 – Server-Side Request Forgery (SSRF)
        owasp_assessment.append({
            'category': 'A10:2021 - Server-Side Request Forgery (SSRF)',
            'status': 'Manual Review Required',
            'severity': 'Medium',
            'findings': 0
        })
        
        self.results['owasp_top10'] = owasp_assessment
    
    def generate_vulnerability_recommendations(self):
        """Generate comprehensive security recommendations"""
        self.update_progress(1, "Generating security recommendations...")
        
        recommendations = []
        
        # SQL Injection recommendations
        if self.results['sql_injection']:
            recommendations.append({
                'priority': 'Critical',
                'category': 'Injection Attacks',
                'action': 'Fix SQL Injection Vulnerabilities',
                'description': 'Implement parameterized queries and input validation to prevent SQL injection attacks'
            })
        
        # XSS recommendations
        if self.results['xss_vulnerabilities']:
            recommendations.append({
                'priority': 'High',
                'category': 'Cross-Site Scripting',
                'action': 'Fix XSS Vulnerabilities',
                'description': 'Implement proper input validation, output encoding, and Content Security Policy'
            })
        
        # Security headers recommendations
        missing_headers = []
        for protocol, headers in self.results['security_headers'].items():
            for header, info in headers.items():
                if not info.get('present', True):
                    missing_headers.append(header)
        
        if missing_headers:
            recommendations.append({
                'priority': 'Medium',
                'category': 'Security Headers',
                'action': 'Implement Missing Security Headers',
                'description': f'Add missing security headers: {", ".join(set(missing_headers))}'
            })
        
        # SSL/TLS recommendations
        if self.results['ssl_vulnerabilities']:
            recommendations.append({
                'priority': 'High',
                'category': 'SSL/TLS Security',
                'action': 'Fix SSL/TLS Configuration',
                'description': 'Update SSL/TLS configuration to use strong ciphers and protocols'
            })
        
        # Authentication recommendations
        if self.results['authentication_issues']:
            recommendations.append({
                'priority': 'Critical',
                'category': 'Authentication Security',
                'action': 'Strengthen Authentication',
                'description': 'Remove default credentials, implement strong password policies, and secure session management'
            })
        
        # Open ports recommendations
        critical_ports = [p for p in self.results['open_ports'] if p['risk_level'] == 'Critical']
        if critical_ports:
            recommendations.append({
                'priority': 'Critical',
                'category': 'Network Security',
                'action': 'Secure Critical Services',
                'description': f'Secure or restrict access to critical services on ports: {", ".join([str(p["port"]) for p in critical_ports])}'
            })
        
        # General recommendations
        recommendations.extend([
            {
                'priority': 'Medium',
                'category': 'Security Monitoring',
                'action': 'Implement Security Monitoring',
                'description': 'Set up logging, monitoring, and alerting for security events'
            },
            {
                'priority': 'Medium',
                'category': 'Regular Updates',
                'action': 'Keep Software Updated',
                'description': 'Regularly update all software components and apply security patches'
            },
            {
                'priority': 'Low',
                'category': 'Security Testing',
                'action': 'Regular Security Testing',
                'description': 'Perform regular security assessments and penetration testing'
            }
        ])
        
        self.results['recommendations'] = recommendations
    
    # Additional vulnerability testing methods for specific services
    def test_ftp_vulnerabilities(self):
        """Test FTP-specific vulnerabilities"""
        # Test anonymous FTP access
        # Test FTP bounce attacks
        # Test weak FTP configurations
        pass
    
    def test_ssh_vulnerabilities(self):
        """Test SSH-specific vulnerabilities"""
        # Test SSH version and algorithms
        # Test for weak SSH configurations
        # Test for SSH key vulnerabilities
        pass
    
    def test_smb_vulnerabilities(self):
        """Test SMB-specific vulnerabilities"""
        # Test for EternalBlue vulnerability
        # Test SMB null sessions
        # Test SMB signing
        pass
    
    def test_database_vulnerabilities(self, port):
        """Test database-specific vulnerabilities"""
        # Test default database credentials
        # Test database version detection
        # Test for database-specific vulnerabilities
        pass